# -*- coding: utf-8 -*-
"""Mind_Mentor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j2XxsiakbcnHFDyEEUAbfWrOMzf0PV6w
"""

import pandas as pd
from matplotlib import pyplot as plt
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
from sklearn.model_selection import train_test_split
from sklearn.pipeline import Pipeline
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.svm import LinearSVC
from sklearn.metrics import confusion_matrix, classification_report, accuracy_score
from transformers import pipeline
import gradio as gr

# Set the column width to view the statements
pd.set_option('max_colwidth', 200)

# Load the dataset
df = pd.read_csv("/content/Combined Data.csv", index_col="Unnamed: 0")
df = df.dropna()  # Drop null values if any

# Basic dataset exploration
print(df.info())
print(df.sample(5))

# Sentiment Analysis using VADER
analyzer = SentimentIntensityAnalyzer()
df['sentiment'] = df['statement'].apply(lambda x: 'Positive' if analyzer.polarity_scores(x)['compound'] >= 0.05 else
                                        ('Negative' if analyzer.polarity_scores(x)['compound'] <= -0.05 else 'Neutral'))
df['score'] = df['statement'].apply(lambda x: analyzer.polarity_scores(x)['compound'])

# Print sample after adding sentiment and score
print(df.sample(10))

# Plotting the sentiment distribution
sentiment_count = df['sentiment'].value_counts()
sentiment_chart = sentiment_count.plot(
    kind='bar',
    facecolor='b',
    title='Sentiment Count',
    xlabel='Sentiment',
    ylabel='# of entries'
)
plt.show()

# Set the features and target variables
X = df['statement']
y_status = df['status']
y_sentiment = df['sentiment']

# Split data into training and testing for status
X_status_train, X_status_test, y_status_train, y_status_test = train_test_split(X, y_status, test_size=0.25, random_state=1)
# Split data into training and testing for sentiment
X_sentiment_train, X_sentiment_test, y_sentiment_train, y_sentiment_test = train_test_split(X, y_sentiment, test_size=0.30, random_state=1)

# Create and train pipeline for 'status' prediction
status_pipeline = Pipeline([
    ('tfidf', TfidfVectorizer(stop_words=None)),
    ('classifier', LinearSVC())
])
status_pipeline.fit(X_status_train, y_status_train)

# Test the model and display results
status_predictions = status_pipeline.predict(X_status_test)
print(f"Status Classification Report:\n{classification_report(y_status_test, status_predictions)}")

# Create and train pipeline for 'sentiment' prediction
sentiment_pipeline = Pipeline([
    ('tfidf', TfidfVectorizer(stop_words=None)),
    ('classifier', LinearSVC())
])
sentiment_pipeline.fit(X_sentiment_train, y_sentiment_train)

# Test the model and display results
sentiment_predictions = sentiment_pipeline.predict(X_sentiment_test)
print(f"Sentiment Classification Report:\n{classification_report(y_sentiment_test, sentiment_predictions)}")

# Use Hugging Face's Transformers for generating responses
# Load a Hugging Face model like 'distilbert-base-uncased'
text_generator = pipeline("text-generation", model="distilgpt2")

# Define the chatbot function
def mental_health_chatbot(statement):
    # Predict status and sentiment
    status = status_pipeline.predict([statement])[0]
    sentiment = sentiment_pipeline.predict([statement])[0]

    # Create a query based on the statement and predictions
    query = (
        f'The statement from the user is: "{statement}".\n'
        f'The mental health status of the user is: "{status}".\n'
        f'The sentiment of the statement is: "{sentiment}".\n'
        "Does the user require any assistance? If so, what would you suggest?"
    )

    # Use Hugging Face model to generate response based on the query
    response = text_generator(query, max_length=100, num_return_sequences=1)
    return response[0]['generated_text']

# Define Gradio interface
app = gr.Interface(
    fn=mental_health_chatbot,
    inputs=gr.Textbox(label="Enter your statement"),
    outputs=gr.Textbox(label="Mental Health Chatbot Response", show_copy_button=True)
)

# Launch the Gradio app
app.launch(show_error=True)